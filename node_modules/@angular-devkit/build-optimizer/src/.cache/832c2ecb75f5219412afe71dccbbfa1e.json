{"remainingRequest":"C:\\Users\\Zac\\Desktop\\2018courses\\sentinel\\Sentinel\\WebApplication\\FrontEnd\\ngx-admin-master\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\Zac\\Desktop\\2018courses\\sentinel\\Sentinel\\WebApplication\\FrontEnd\\ngx-admin-master\\node_modules\\ng2-tree\\src\\tree.js","dependencies":[{"path":"C:\\Users\\Zac\\Desktop\\2018courses\\sentinel\\Sentinel\\WebApplication\\FrontEnd\\ngx-admin-master\\node_modules\\ng2-tree\\src\\tree.js","mtime":1511605106000},{"path":"C:\\Users\\Zac\\Desktop\\2018courses\\sentinel\\Sentinel\\WebApplication\\FrontEnd\\ngx-admin-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1527928412363},{"path":"C:\\Users\\Zac\\Desktop\\2018courses\\sentinel\\Sentinel\\WebApplication\\FrontEnd\\ngx-admin-master\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1525376550000}],"contextDependencies":[],"result":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar fn_utils_1 = require(\"./utils/fn.utils\");\r\nvar Observable_1 = require(\"rxjs/Observable\");\r\nvar tree_types_1 = require(\"./tree.types\");\r\nvar uuidv4 = require(\"uuid/v4\");\r\nvar ChildrenLoadingState = /*@__PURE__*/ (function (ChildrenLoadingState) {\r\n    ChildrenLoadingState[ChildrenLoadingState[\"NotStarted\"] = 0] = \"NotStarted\";\r\n    ChildrenLoadingState[ChildrenLoadingState[\"Loading\"] = 1] = \"Loading\";\r\n    ChildrenLoadingState[ChildrenLoadingState[\"Completed\"] = 2] = \"Completed\";\r\n    return ChildrenLoadingState;\r\n})({});\r\nvar Tree = /*@__PURE__*/ (function () {\r\n    /**\r\n     * Build an instance of Tree from an object implementing TreeModel interface.\r\n     * @param {TreeModel} model - A model that is used to build a tree.\r\n     * @param {Tree} [parent] - An optional parent if you want to build a tree from the model that should be a child of an existing Tree instance.\r\n     * @param {boolean} [isBranch] - An option that makes a branch from created tree. Branch can have children.\r\n     */\r\n    function Tree(node, parent, isBranch) {\r\n        if (parent === void 0) {\r\n            parent = null;\r\n        }\r\n        if (isBranch === void 0) {\r\n            isBranch = false;\r\n        }\r\n        var _this = this;\r\n        this._childrenLoadingState = ChildrenLoadingState.NotStarted;\r\n        this._childrenAsyncOnce = fn_utils_1.once(function () {\r\n            return new Observable_1.Observable(function (observer) {\r\n                setTimeout(function () {\r\n                    _this._childrenLoadingState = ChildrenLoadingState.Loading;\r\n                    _this._loadChildren(function (children) {\r\n                        _this._children = (children || []).map(function (child) { return new Tree(child, _this); });\r\n                        _this._childrenLoadingState = ChildrenLoadingState.Completed;\r\n                        observer.next(_this.children);\r\n                        observer.complete();\r\n                    });\r\n                });\r\n            });\r\n        });\r\n        this.buildTreeFromModel(node, parent, isBranch || Array.isArray(node.children));\r\n    }\r\n    // STATIC METHODS ----------------------------------------------------------------------------------------------------\r\n    /**\r\n     * Check that value passed is not empty (it doesn't consist of only whitespace symbols).\r\n     * @param {string} value - A value that should be checked.\r\n     * @returns {boolean} - A flag indicating that value is empty or not.\r\n     * @static\r\n     */\r\n    // STATIC METHODS ----------------------------------------------------------------------------------------------------\r\n    /**\r\n       * Check that value passed is not empty (it doesn't consist of only whitespace symbols).\r\n       * @param {string} value - A value that should be checked.\r\n       * @returns {boolean} - A flag indicating that value is empty or not.\r\n       * @static\r\n       */\r\n    Tree.isValueEmpty =\r\n        // STATIC METHODS ----------------------------------------------------------------------------------------------------\r\n        /**\r\n           * Check that value passed is not empty (it doesn't consist of only whitespace symbols).\r\n           * @param {string} value - A value that should be checked.\r\n           * @returns {boolean} - A flag indicating that value is empty or not.\r\n           * @static\r\n           */\r\n        function (value) {\r\n            return fn_utils_1.isEmpty(fn_utils_1.trim(value));\r\n        };\r\n    /**\r\n     * Check whether a given value can be considered RenamableNode.\r\n     * @param {any} value - A value to check.\r\n     * @returns {boolean} - A flag indicating whether given value is Renamable node or not.\r\n     * @static\r\n     */\r\n    /**\r\n       * Check whether a given value can be considered RenamableNode.\r\n       * @param {any} value - A value to check.\r\n       * @returns {boolean} - A flag indicating whether given value is Renamable node or not.\r\n       * @static\r\n       */\r\n    Tree.isRenamable = /**\r\n       * Check whether a given value can be considered RenamableNode.\r\n       * @param {any} value - A value to check.\r\n       * @returns {boolean} - A flag indicating whether given value is Renamable node or not.\r\n       * @static\r\n       */\r\n        function (value) {\r\n            return (fn_utils_1.has(value, 'setName') && fn_utils_1.isFunction(value.setName))\r\n                && (fn_utils_1.has(value, 'toString') && fn_utils_1.isFunction(value.toString) && value.toString !== Object.toString);\r\n        };\r\n    Tree.cloneTreeShallow = function (origin) {\r\n        var tree = new Tree(Object.assign({}, origin.node));\r\n        tree._children = origin._children;\r\n        return tree;\r\n    };\r\n    Tree.applyNewValueToRenamable = function (value, newValue) {\r\n        var renamableValue = Object.assign({}, value);\r\n        renamableValue.setName(newValue);\r\n        return renamableValue;\r\n    };\r\n    Tree.prototype.buildTreeFromModel = function (model, parent, isBranch) {\r\n        var _this = this;\r\n        this.parent = parent;\r\n        this.node = Object.assign(fn_utils_1.omit(model, 'children'), {\r\n            settings: tree_types_1.TreeModelSettings.merge(model, fn_utils_1.get(parent, 'node'))\r\n        }, { emitLoadNextLevel: model.emitLoadNextLevel === true });\r\n        if (fn_utils_1.isFunction(this.node.loadChildren)) {\r\n            this._loadChildren = this.node.loadChildren;\r\n        }\r\n        else {\r\n            fn_utils_1.get(model, 'children', []).forEach(function (child, index) {\r\n                _this._addChild(new Tree(child, _this), index);\r\n            });\r\n        }\r\n        if (!Array.isArray(this._children)) {\r\n            this._children = this.node.loadChildren || isBranch ? [] : null;\r\n        }\r\n    };\r\n    Tree.prototype.hasDeferredChildren = function () {\r\n        return typeof this._loadChildren === 'function';\r\n    };\r\n    /* Setting the children loading state to Loading since a request was dispatched to the client */\r\n    /* Setting the children loading state to Loading since a request was dispatched to the client */\r\n    Tree.prototype.loadingChildrenRequested = /* Setting the children loading state to Loading since a request was dispatched to the client */\r\n        function () {\r\n            this._childrenLoadingState = ChildrenLoadingState.Loading;\r\n        };\r\n    /**\r\n     * Check whether children of the node are being loaded.\r\n     * Makes sense only for nodes that define `loadChildren` function.\r\n     * @returns {boolean} A flag indicating that children are being loaded.\r\n     */\r\n    /**\r\n       * Check whether children of the node are being loaded.\r\n       * Makes sense only for nodes that define `loadChildren` function.\r\n       * @returns {boolean} A flag indicating that children are being loaded.\r\n       */\r\n    Tree.prototype.childrenAreBeingLoaded = /**\r\n       * Check whether children of the node are being loaded.\r\n       * Makes sense only for nodes that define `loadChildren` function.\r\n       * @returns {boolean} A flag indicating that children are being loaded.\r\n       */\r\n        function () {\r\n            return (this._childrenLoadingState === ChildrenLoadingState.Loading);\r\n        };\r\n    /**\r\n     * Check whether children of the node were loaded.\r\n     * Makes sense only for nodes that define `loadChildren` function.\r\n     * @returns {boolean} A flag indicating that children were loaded.\r\n     */\r\n    /**\r\n       * Check whether children of the node were loaded.\r\n       * Makes sense only for nodes that define `loadChildren` function.\r\n       * @returns {boolean} A flag indicating that children were loaded.\r\n       */\r\n    Tree.prototype.childrenWereLoaded = /**\r\n       * Check whether children of the node were loaded.\r\n       * Makes sense only for nodes that define `loadChildren` function.\r\n       * @returns {boolean} A flag indicating that children were loaded.\r\n       */\r\n        function () {\r\n            return (this._childrenLoadingState === ChildrenLoadingState.Completed);\r\n        };\r\n    Tree.prototype.canLoadChildren = function () {\r\n        return (this._childrenLoadingState === ChildrenLoadingState.NotStarted)\r\n            && (this.foldingType === tree_types_1.FoldingType.Expanded)\r\n            && (!!this._loadChildren);\r\n    };\r\n    /**\r\n     * Check whether children of the node should be loaded and not loaded yet.\r\n     * Makes sense only for nodes that define `loadChildren` function.\r\n     * @returns {boolean} A flag indicating that children should be loaded for the current node.\r\n     */\r\n    /**\r\n       * Check whether children of the node should be loaded and not loaded yet.\r\n       * Makes sense only for nodes that define `loadChildren` function.\r\n       * @returns {boolean} A flag indicating that children should be loaded for the current node.\r\n       */\r\n    Tree.prototype.childrenShouldBeLoaded = /**\r\n       * Check whether children of the node should be loaded and not loaded yet.\r\n       * Makes sense only for nodes that define `loadChildren` function.\r\n       * @returns {boolean} A flag indicating that children should be loaded for the current node.\r\n       */\r\n        function () {\r\n            return !this.childrenWereLoaded() && (!!this._loadChildren || this.node.emitLoadNextLevel === true);\r\n        };\r\n    Object.defineProperty(Tree.prototype, \"children\", {\r\n        /**\r\n         * Get children of the current tree.\r\n         * @returns {Tree[]} The children of the current tree.\r\n         */\r\n        get: /**\r\n           * Get children of the current tree.\r\n           * @returns {Tree[]} The children of the current tree.\r\n           */ function () {\r\n            return this._children;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tree.prototype, \"childrenAsync\", {\r\n        /**\r\n         * By getting value from this property you start process of loading node's children using `loadChildren` function.\r\n         * Once children are loaded `loadChildren` function won't be called anymore and loaded for the first time children are emitted in case of subsequent calls.\r\n         * @returns {Observable<Tree[]>} An observable which emits children once they are loaded.\r\n         */\r\n        get: /**\r\n           * By getting value from this property you start process of loading node's children using `loadChildren` function.\r\n           * Once children are loaded `loadChildren` function won't be called anymore and loaded for the first time children are emitted in case of subsequent calls.\r\n           * @returns {Observable<Tree[]>} An observable which emits children once they are loaded.\r\n           */ function () {\r\n            if (this.canLoadChildren()) {\r\n                return this._childrenAsyncOnce();\r\n            }\r\n            return Observable_1.Observable.of(this.children);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * By calling this method you start process of loading node's children using `loadChildren` function.\r\n     */\r\n    /**\r\n       * By calling this method you start process of loading node's children using `loadChildren` function.\r\n       */\r\n    Tree.prototype.reloadChildren = /**\r\n       * By calling this method you start process of loading node's children using `loadChildren` function.\r\n       */\r\n        function () {\r\n            var _this = this;\r\n            if (this.childrenShouldBeLoaded()) {\r\n                this._childrenLoadingState = ChildrenLoadingState.Loading;\r\n                this._loadChildren(function (children) {\r\n                    _this._children = children && children.map(function (child) { return new Tree(child, _this); });\r\n                    _this._childrenLoadingState = ChildrenLoadingState.Completed;\r\n                });\r\n            }\r\n        };\r\n    /**\r\n     * By calling this method you will remove all current children of a treee and create new.\r\n     */\r\n    /**\r\n       * By calling this method you will remove all current children of a treee and create new.\r\n       */\r\n    Tree.prototype.setChildren = /**\r\n       * By calling this method you will remove all current children of a treee and create new.\r\n       */\r\n        function (children) {\r\n            var _this = this;\r\n            this._children = children && children.map(function (child) { return new Tree(child, _this); });\r\n            if (this.childrenShouldBeLoaded()) {\r\n                this._childrenLoadingState = ChildrenLoadingState.Completed;\r\n            }\r\n        };\r\n    /**\r\n     * Create a new node in the current tree.\r\n     * @param {boolean} isBranch - A flag that indicates whether a new node should be a \"Branch\". \"Leaf\" node will be created by default\r\n     * @param {TreeModel} model - Tree model of the new node which will be inserted. Empty node will be created by default and it will fire edit mode of this node\r\n     * @returns {Tree} A newly created child node.\r\n     */\r\n    /**\r\n       * Create a new node in the current tree.\r\n       * @param {boolean} isBranch - A flag that indicates whether a new node should be a \"Branch\". \"Leaf\" node will be created by default\r\n       * @param {TreeModel} model - Tree model of the new node which will be inserted. Empty node will be created by default and it will fire edit mode of this node\r\n       * @returns {Tree} A newly created child node.\r\n       */\r\n    Tree.prototype.createNode = /**\r\n       * Create a new node in the current tree.\r\n       * @param {boolean} isBranch - A flag that indicates whether a new node should be a \"Branch\". \"Leaf\" node will be created by default\r\n       * @param {TreeModel} model - Tree model of the new node which will be inserted. Empty node will be created by default and it will fire edit mode of this node\r\n       * @returns {Tree} A newly created child node.\r\n       */\r\n        function (isBranch, model) {\r\n            if (model === void 0) {\r\n                model = { value: '' };\r\n            }\r\n            var tree = new Tree(model, this, isBranch);\r\n            if (!model.id) {\r\n                tree.markAsNew();\r\n            }\r\n            tree.id = tree.id || uuidv4();\r\n            if (this.childrenShouldBeLoaded() && !(this.childrenAreBeingLoaded() || this.childrenWereLoaded())) {\r\n                return null;\r\n            }\r\n            if (this.isLeaf()) {\r\n                return this.addSibling(tree);\r\n            }\r\n            else {\r\n                return this.addChild(tree);\r\n            }\r\n        };\r\n    Object.defineProperty(Tree.prototype, \"value\", {\r\n        /**\r\n         * Get the value of the current node\r\n         * @returns {(string|RenamableNode)} The value of the node.\r\n         */\r\n        get: /**\r\n           * Get the value of the current node\r\n           * @returns {(string|RenamableNode)} The value of the node.\r\n           */ function () {\r\n            return this.node.value;\r\n        },\r\n        /**\r\n         * Set the value of the current node\r\n         * @param {(string|RenamableNode)} value - The new value of the node.\r\n         */\r\n        set: /**\r\n           * Set the value of the current node\r\n           * @param {(string|RenamableNode)} value - The new value of the node.\r\n           */ function (value) {\r\n            if (typeof value !== 'string' && !Tree.isRenamable(value)) {\r\n                return;\r\n            }\r\n            var stringifiedValue = '' + value;\r\n            if (Tree.isRenamable(this.value)) {\r\n                this.node.value = Tree.applyNewValueToRenamable(this.value, stringifiedValue);\r\n            }\r\n            else {\r\n                this.node.value = Tree.isValueEmpty(stringifiedValue) ? this.node.value : stringifiedValue;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Add a sibling node for the current node. This won't work if the current node is a root.\r\n     * @param {Tree} sibling - A node that should become a sibling.\r\n     * @param [number] position - Position in which sibling will be inserted. By default it will be inserted at the last position in a parent.\r\n     * @returns {Tree} A newly inserted sibling, or null if you are trying to make a sibling for the root.\r\n     */\r\n    /**\r\n       * Add a sibling node for the current node. This won't work if the current node is a root.\r\n       * @param {Tree} sibling - A node that should become a sibling.\r\n       * @param [number] position - Position in which sibling will be inserted. By default it will be inserted at the last position in a parent.\r\n       * @returns {Tree} A newly inserted sibling, or null if you are trying to make a sibling for the root.\r\n       */\r\n    Tree.prototype.addSibling = /**\r\n       * Add a sibling node for the current node. This won't work if the current node is a root.\r\n       * @param {Tree} sibling - A node that should become a sibling.\r\n       * @param [number] position - Position in which sibling will be inserted. By default it will be inserted at the last position in a parent.\r\n       * @returns {Tree} A newly inserted sibling, or null if you are trying to make a sibling for the root.\r\n       */\r\n        function (sibling, position) {\r\n            if (Array.isArray(fn_utils_1.get(this.parent, 'children'))) {\r\n                return this.parent.addChild(sibling, position);\r\n            }\r\n            return null;\r\n        };\r\n    /**\r\n     * Add a child node for the current node.\r\n     * @param {Tree} child - A node that should become a child.\r\n     * @param [number] position - Position in which child will be inserted. By default it will be inserted at the last position in a parent.\r\n     * @returns {Tree} A newly inserted child.\r\n     */\r\n    /**\r\n       * Add a child node for the current node.\r\n       * @param {Tree} child - A node that should become a child.\r\n       * @param [number] position - Position in which child will be inserted. By default it will be inserted at the last position in a parent.\r\n       * @returns {Tree} A newly inserted child.\r\n       */\r\n    Tree.prototype.addChild = /**\r\n       * Add a child node for the current node.\r\n       * @param {Tree} child - A node that should become a child.\r\n       * @param [number] position - Position in which child will be inserted. By default it will be inserted at the last position in a parent.\r\n       * @returns {Tree} A newly inserted child.\r\n       */\r\n        function (child, position) {\r\n            var newborn = this._addChild(Tree.cloneTreeShallow(child), position);\r\n            this._setFoldingType();\r\n            if (this.isNodeCollapsed()) {\r\n                this.switchFoldingType();\r\n            }\r\n            return newborn;\r\n        };\r\n    Tree.prototype._addChild = function (child, position) {\r\n        if (position === void 0) {\r\n            position = fn_utils_1.size(this._children) || 0;\r\n        }\r\n        child.parent = this;\r\n        if (Array.isArray(this._children)) {\r\n            this._children.splice(position, 0, child);\r\n        }\r\n        else {\r\n            this._children = [child];\r\n        }\r\n        return child;\r\n    };\r\n    /**\r\n     * Swap position of the current node with the given sibling. If node passed as a parameter is not a sibling - nothing happens.\r\n     * @param {Tree} sibling - A sibling with which current node shold be swapped.\r\n     */\r\n    /**\r\n       * Swap position of the current node with the given sibling. If node passed as a parameter is not a sibling - nothing happens.\r\n       * @param {Tree} sibling - A sibling with which current node shold be swapped.\r\n       */\r\n    Tree.prototype.swapWithSibling = /**\r\n       * Swap position of the current node with the given sibling. If node passed as a parameter is not a sibling - nothing happens.\r\n       * @param {Tree} sibling - A sibling with which current node shold be swapped.\r\n       */\r\n        function (sibling) {\r\n            if (!this.hasSibling(sibling)) {\r\n                return;\r\n            }\r\n            var siblingIndex = sibling.positionInParent;\r\n            var thisTreeIndex = this.positionInParent;\r\n            this.parent._children[siblingIndex] = this;\r\n            this.parent._children[thisTreeIndex] = sibling;\r\n        };\r\n    Object.defineProperty(Tree.prototype, \"positionInParent\", {\r\n        /**\r\n         * Get a node's position in its parent.\r\n         * @returns {number} The position inside a parent.\r\n         */\r\n        get: /**\r\n           * Get a node's position in its parent.\r\n           * @returns {number} The position inside a parent.\r\n           */ function () {\r\n            if (this.isRoot()) {\r\n                return -1;\r\n            }\r\n            return this.parent.children ? this.parent.children.indexOf(this) : -1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Check whether or not this tree is static.\r\n     * @returns {boolean} A flag indicating whether or not this tree is static.\r\n     */\r\n    /**\r\n       * Check whether or not this tree is static.\r\n       * @returns {boolean} A flag indicating whether or not this tree is static.\r\n       */\r\n    Tree.prototype.isStatic = /**\r\n       * Check whether or not this tree is static.\r\n       * @returns {boolean} A flag indicating whether or not this tree is static.\r\n       */\r\n        function () {\r\n            return fn_utils_1.get(this.node.settings, 'static', false);\r\n        };\r\n    /**\r\n     * Check whether or not this tree has a left menu.\r\n     * @returns {boolean} A flag indicating whether or not this tree has a left menu.\r\n     */\r\n    /**\r\n       * Check whether or not this tree has a left menu.\r\n       * @returns {boolean} A flag indicating whether or not this tree has a left menu.\r\n       */\r\n    Tree.prototype.hasLeftMenu = /**\r\n       * Check whether or not this tree has a left menu.\r\n       * @returns {boolean} A flag indicating whether or not this tree has a left menu.\r\n       */\r\n        function () {\r\n            return !fn_utils_1.get(this.node.settings, 'static', false) && fn_utils_1.get(this.node.settings, 'leftMenu', false);\r\n        };\r\n    /**\r\n     * Check whether or not this tree has a right menu.\r\n     * @returns {boolean} A flag indicating whether or not this tree has a right menu.\r\n     */\r\n    /**\r\n       * Check whether or not this tree has a right menu.\r\n       * @returns {boolean} A flag indicating whether or not this tree has a right menu.\r\n       */\r\n    Tree.prototype.hasRightMenu = /**\r\n       * Check whether or not this tree has a right menu.\r\n       * @returns {boolean} A flag indicating whether or not this tree has a right menu.\r\n       */\r\n        function () {\r\n            return !fn_utils_1.get(this.node.settings, 'static', false) && fn_utils_1.get(this.node.settings, 'rightMenu', false);\r\n        };\r\n    /**\r\n     * Check whether this tree is \"Leaf\" or not.\r\n     * @returns {boolean} A flag indicating whether or not this tree is a \"Leaf\".\r\n     */\r\n    /**\r\n       * Check whether this tree is \"Leaf\" or not.\r\n       * @returns {boolean} A flag indicating whether or not this tree is a \"Leaf\".\r\n       */\r\n    Tree.prototype.isLeaf = /**\r\n       * Check whether this tree is \"Leaf\" or not.\r\n       * @returns {boolean} A flag indicating whether or not this tree is a \"Leaf\".\r\n       */\r\n        function () {\r\n            return !this.isBranch();\r\n        };\r\n    Object.defineProperty(Tree.prototype, \"menuItems\", {\r\n        /**\r\n         * Get menu items of the current tree.\r\n         * @returns {NodeMenuItem[]} The menu items of the current tree.\r\n         */\r\n        get: /**\r\n           * Get menu items of the current tree.\r\n           * @returns {NodeMenuItem[]} The menu items of the current tree.\r\n           */ function () {\r\n            return fn_utils_1.get(this.node.settings, 'menuItems');\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Check whether or not this tree has a custom menu.\r\n     * @returns {boolean} A flag indicating whether or not this tree has a custom menu.\r\n     */\r\n    /**\r\n       * Check whether or not this tree has a custom menu.\r\n       * @returns {boolean} A flag indicating whether or not this tree has a custom menu.\r\n       */\r\n    Tree.prototype.hasCustomMenu = /**\r\n       * Check whether or not this tree has a custom menu.\r\n       * @returns {boolean} A flag indicating whether or not this tree has a custom menu.\r\n       */\r\n        function () {\r\n            return !this.isStatic() && !!fn_utils_1.get(this.node.settings, 'menuItems', false);\r\n        };\r\n    /**\r\n     * Check whether this tree is \"Branch\" or not. \"Branch\" is a node that has children.\r\n     * @returns {boolean} A flag indicating whether or not this tree is a \"Branch\".\r\n     */\r\n    /**\r\n       * Check whether this tree is \"Branch\" or not. \"Branch\" is a node that has children.\r\n       * @returns {boolean} A flag indicating whether or not this tree is a \"Branch\".\r\n       */\r\n    Tree.prototype.isBranch = /**\r\n       * Check whether this tree is \"Branch\" or not. \"Branch\" is a node that has children.\r\n       * @returns {boolean} A flag indicating whether or not this tree is a \"Branch\".\r\n       */\r\n        function () {\r\n            return this.node.emitLoadNextLevel === true || Array.isArray(this._children);\r\n        };\r\n    /**\r\n     * Check whether this tree has children.\r\n     * @returns {boolean} A flag indicating whether or not this tree has children.\r\n     */\r\n    /**\r\n       * Check whether this tree has children.\r\n       * @returns {boolean} A flag indicating whether or not this tree has children.\r\n       */\r\n    Tree.prototype.hasChildren = /**\r\n       * Check whether this tree has children.\r\n       * @returns {boolean} A flag indicating whether or not this tree has children.\r\n       */\r\n        function () {\r\n            return !fn_utils_1.isEmpty(this._children) || this.childrenShouldBeLoaded();\r\n        };\r\n    /**\r\n     * Check whether this tree is a root or not. The root is the tree (node) that doesn't have parent (or technically its parent is null).\r\n     * @returns {boolean} A flag indicating whether or not this tree is the root.\r\n     */\r\n    /**\r\n       * Check whether this tree is a root or not. The root is the tree (node) that doesn't have parent (or technically its parent is null).\r\n       * @returns {boolean} A flag indicating whether or not this tree is the root.\r\n       */\r\n    Tree.prototype.isRoot = /**\r\n       * Check whether this tree is a root or not. The root is the tree (node) that doesn't have parent (or technically its parent is null).\r\n       * @returns {boolean} A flag indicating whether or not this tree is the root.\r\n       */\r\n        function () {\r\n            return fn_utils_1.isNil(this.parent);\r\n        };\r\n    /**\r\n     * Check whether provided tree is a sibling of the current tree. Sibling trees (nodes) are the trees that have the same parent.\r\n     * @param {Tree} tree - A tree that should be tested on a siblingness.\r\n     * @returns {boolean} A flag indicating whether or not provided tree is the sibling of the current one.\r\n     */\r\n    /**\r\n       * Check whether provided tree is a sibling of the current tree. Sibling trees (nodes) are the trees that have the same parent.\r\n       * @param {Tree} tree - A tree that should be tested on a siblingness.\r\n       * @returns {boolean} A flag indicating whether or not provided tree is the sibling of the current one.\r\n       */\r\n    Tree.prototype.hasSibling = /**\r\n       * Check whether provided tree is a sibling of the current tree. Sibling trees (nodes) are the trees that have the same parent.\r\n       * @param {Tree} tree - A tree that should be tested on a siblingness.\r\n       * @returns {boolean} A flag indicating whether or not provided tree is the sibling of the current one.\r\n       */\r\n        function (tree) {\r\n            return !this.isRoot() && fn_utils_1.includes(this.parent.children, tree);\r\n        };\r\n    /**\r\n     * Check whether provided tree is a child of the current tree.\r\n     * This method tests that provided tree is a <strong>direct</strong> child of the current tree.\r\n     * @param {Tree} tree - A tree that should be tested (child candidate).\r\n     * @returns {boolean} A flag indicating whether provided tree is a child or not.\r\n     */\r\n    /**\r\n       * Check whether provided tree is a child of the current tree.\r\n       * This method tests that provided tree is a <strong>direct</strong> child of the current tree.\r\n       * @param {Tree} tree - A tree that should be tested (child candidate).\r\n       * @returns {boolean} A flag indicating whether provided tree is a child or not.\r\n       */\r\n    Tree.prototype.hasChild = /**\r\n       * Check whether provided tree is a child of the current tree.\r\n       * This method tests that provided tree is a <strong>direct</strong> child of the current tree.\r\n       * @param {Tree} tree - A tree that should be tested (child candidate).\r\n       * @returns {boolean} A flag indicating whether provided tree is a child or not.\r\n       */\r\n        function (tree) {\r\n            return fn_utils_1.includes(this._children, tree);\r\n        };\r\n    /**\r\n     * Remove given tree from the current tree.\r\n     * The given tree will be removed only in case it is a direct child of the current tree (@see {@link hasChild}).\r\n     * @param {Tree} tree - A tree that should be removed.\r\n     */\r\n    /**\r\n       * Remove given tree from the current tree.\r\n       * The given tree will be removed only in case it is a direct child of the current tree (@see {@link hasChild}).\r\n       * @param {Tree} tree - A tree that should be removed.\r\n       */\r\n    Tree.prototype.removeChild = /**\r\n       * Remove given tree from the current tree.\r\n       * The given tree will be removed only in case it is a direct child of the current tree (@see {@link hasChild}).\r\n       * @param {Tree} tree - A tree that should be removed.\r\n       */\r\n        function (tree) {\r\n            if (!this.hasChildren()) {\r\n                return;\r\n            }\r\n            var childIndex = this._children.findIndex(function (child) { return child === tree; });\r\n            if (childIndex >= 0) {\r\n                this._children.splice(childIndex, 1);\r\n            }\r\n            this._setFoldingType();\r\n        };\r\n    /**\r\n     * Remove current tree from its parent.\r\n     */\r\n    /**\r\n       * Remove current tree from its parent.\r\n       */\r\n    Tree.prototype.removeItselfFromParent = /**\r\n       * Remove current tree from its parent.\r\n       */\r\n        function () {\r\n            if (!this.parent) {\r\n                return;\r\n            }\r\n            this.parent.removeChild(this);\r\n        };\r\n    /**\r\n     * Switch folding type of the current tree. \"Leaf\" node cannot switch its folding type cause it doesn't have children, hence nothing to fold.\r\n     * If node is a \"Branch\" and it is expanded, then by invoking current method state of the tree should be switched to \"collapsed\" and vice versa.\r\n     */\r\n    /**\r\n       * Switch folding type of the current tree. \"Leaf\" node cannot switch its folding type cause it doesn't have children, hence nothing to fold.\r\n       * If node is a \"Branch\" and it is expanded, then by invoking current method state of the tree should be switched to \"collapsed\" and vice versa.\r\n       */\r\n    Tree.prototype.switchFoldingType = /**\r\n       * Switch folding type of the current tree. \"Leaf\" node cannot switch its folding type cause it doesn't have children, hence nothing to fold.\r\n       * If node is a \"Branch\" and it is expanded, then by invoking current method state of the tree should be switched to \"collapsed\" and vice versa.\r\n       */\r\n        function () {\r\n            if (this.isLeaf() || !this.hasChildren()) {\r\n                return;\r\n            }\r\n            this.disableCollapseOnInit();\r\n            this.node._foldingType = this.isNodeExpanded() ? tree_types_1.FoldingType.Collapsed : tree_types_1.FoldingType.Expanded;\r\n        };\r\n    /**\r\n     * Check that tree is expanded.\r\n     * @returns {boolean} A flag indicating whether current tree is expanded. Always returns false for the \"Leaf\" tree and for an empty tree.\r\n     */\r\n    /**\r\n       * Check that tree is expanded.\r\n       * @returns {boolean} A flag indicating whether current tree is expanded. Always returns false for the \"Leaf\" tree and for an empty tree.\r\n       */\r\n    Tree.prototype.isNodeExpanded = /**\r\n       * Check that tree is expanded.\r\n       * @returns {boolean} A flag indicating whether current tree is expanded. Always returns false for the \"Leaf\" tree and for an empty tree.\r\n       */\r\n        function () {\r\n            return this.foldingType === tree_types_1.FoldingType.Expanded;\r\n        };\r\n    /**\r\n     * Check that tree is collapsed.\r\n     * @returns {boolean} A flag indicating whether current tree is collapsed. Always returns false for the \"Leaf\" tree and for an empty tree.\r\n     */\r\n    /**\r\n       * Check that tree is collapsed.\r\n       * @returns {boolean} A flag indicating whether current tree is collapsed. Always returns false for the \"Leaf\" tree and for an empty tree.\r\n       */\r\n    Tree.prototype.isNodeCollapsed = /**\r\n       * Check that tree is collapsed.\r\n       * @returns {boolean} A flag indicating whether current tree is collapsed. Always returns false for the \"Leaf\" tree and for an empty tree.\r\n       */\r\n        function () {\r\n            return this.foldingType === tree_types_1.FoldingType.Collapsed;\r\n        };\r\n    /**\r\n     * Set a current folding type: expanded, collapsed or leaf.\r\n     */\r\n    /**\r\n       * Set a current folding type: expanded, collapsed or leaf.\r\n       */\r\n    Tree.prototype._setFoldingType = /**\r\n       * Set a current folding type: expanded, collapsed or leaf.\r\n       */\r\n        function () {\r\n            if (this.childrenShouldBeLoaded()) {\r\n                this.node._foldingType = tree_types_1.FoldingType.Collapsed;\r\n            }\r\n            else if (this._children && !fn_utils_1.isEmpty(this._children)) {\r\n                this.node._foldingType = this.isCollapsedOnInit() ? tree_types_1.FoldingType.Collapsed : tree_types_1.FoldingType.Expanded;\r\n            }\r\n            else if (Array.isArray(this._children)) {\r\n                this.node._foldingType = tree_types_1.FoldingType.Empty;\r\n            }\r\n            else {\r\n                this.node._foldingType = tree_types_1.FoldingType.Leaf;\r\n            }\r\n        };\r\n    Object.defineProperty(Tree.prototype, \"foldingType\", {\r\n        /**\r\n         * Get a current folding type: expanded, collapsed or leaf.\r\n         * @returns {FoldingType} A folding type of the current tree.\r\n         */\r\n        get: /**\r\n           * Get a current folding type: expanded, collapsed or leaf.\r\n           * @returns {FoldingType} A folding type of the current tree.\r\n           */ function () {\r\n            if (!this.node._foldingType) {\r\n                this._setFoldingType();\r\n            }\r\n            return this.node._foldingType;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tree.prototype, \"foldingCssClass\", {\r\n        /**\r\n         * Get a css class for element which displayes folding state - expanded, collapsed or leaf\r\n         * @returns {string} A string icontaining css class (classes)\r\n         */\r\n        get: /**\r\n           * Get a css class for element which displayes folding state - expanded, collapsed or leaf\r\n           * @returns {string} A string icontaining css class (classes)\r\n           */ function () {\r\n            return this.getCssClassesFromSettings() || this.foldingType.cssClass;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Tree.prototype.getCssClassesFromSettings = function () {\r\n        if (!this.node._foldingType) {\r\n            this._setFoldingType();\r\n        }\r\n        if (this.node._foldingType === tree_types_1.FoldingType.Collapsed) {\r\n            return fn_utils_1.get(this.node.settings, 'cssClasses.collapsed', null);\r\n        }\r\n        else if (this.node._foldingType === tree_types_1.FoldingType.Expanded) {\r\n            return fn_utils_1.get(this.node.settings, 'cssClasses.expanded', null);\r\n        }\r\n        else if (this.node._foldingType === tree_types_1.FoldingType.Empty) {\r\n            return fn_utils_1.get(this.node.settings, 'cssClasses.empty', null);\r\n        }\r\n        return fn_utils_1.get(this.node.settings, 'cssClasses.leaf', null);\r\n    };\r\n    Object.defineProperty(Tree.prototype, \"nodeTemplate\", {\r\n        /**\r\n         * Get a html template to render before every node's name.\r\n         * @returns {string} A string representing a html template.\r\n         */\r\n        get: /**\r\n           * Get a html template to render before every node's name.\r\n           * @returns {string} A string representing a html template.\r\n           */ function () {\r\n            return this.getTemplateFromSettings();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Tree.prototype.getTemplateFromSettings = function () {\r\n        if (this.isLeaf()) {\r\n            return fn_utils_1.get(this.node.settings, 'templates.leaf', '');\r\n        }\r\n        else {\r\n            return fn_utils_1.get(this.node.settings, 'templates.node', '');\r\n        }\r\n    };\r\n    Object.defineProperty(Tree.prototype, \"leftMenuTemplate\", {\r\n        /**\r\n         * Get a html template to render for an element activatin left menu of a node.\r\n         * @returns {string} A string representing a html template.\r\n         */\r\n        get: /**\r\n           * Get a html template to render for an element activatin left menu of a node.\r\n           * @returns {string} A string representing a html template.\r\n           */ function () {\r\n            if (this.hasLeftMenu()) {\r\n                return fn_utils_1.get(this.node.settings, 'templates.leftMenu', '<span></span>');\r\n            }\r\n            return '';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Tree.prototype.disableCollapseOnInit = function () {\r\n        if (this.node.settings) {\r\n            this.node.settings.isCollapsedOnInit = false;\r\n        }\r\n    };\r\n    Tree.prototype.isCollapsedOnInit = function () {\r\n        return !!fn_utils_1.get(this.node.settings, 'isCollapsedOnInit');\r\n    };\r\n    /**\r\n     * Check that current tree is newly created (added by user via menu for example). Tree that was built from the TreeModel is not marked as new.\r\n     * @returns {boolean} A flag whether the tree is new.\r\n     */\r\n    /**\r\n       * Check that current tree is newly created (added by user via menu for example). Tree that was built from the TreeModel is not marked as new.\r\n       * @returns {boolean} A flag whether the tree is new.\r\n       */\r\n    Tree.prototype.isNew = /**\r\n       * Check that current tree is newly created (added by user via menu for example). Tree that was built from the TreeModel is not marked as new.\r\n       * @returns {boolean} A flag whether the tree is new.\r\n       */\r\n        function () {\r\n            return this.node._status === tree_types_1.TreeStatus.New;\r\n        };\r\n    Object.defineProperty(Tree.prototype, \"id\", {\r\n        get: function () {\r\n            return fn_utils_1.get(this.node, 'id');\r\n        },\r\n        set: function (id) {\r\n            this.node.id = id;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Mark current tree as new (@see {@link isNew}).\r\n     */\r\n    /**\r\n       * Mark current tree as new (@see {@link isNew}).\r\n       */\r\n    Tree.prototype.markAsNew = /**\r\n       * Mark current tree as new (@see {@link isNew}).\r\n       */\r\n        function () {\r\n            this.node._status = tree_types_1.TreeStatus.New;\r\n        };\r\n    /**\r\n     * Check that current tree is being renamed (it is in the process of its value renaming initiated by a user).\r\n     * @returns {boolean} A flag whether the tree is being renamed.\r\n     */\r\n    /**\r\n       * Check that current tree is being renamed (it is in the process of its value renaming initiated by a user).\r\n       * @returns {boolean} A flag whether the tree is being renamed.\r\n       */\r\n    Tree.prototype.isBeingRenamed = /**\r\n       * Check that current tree is being renamed (it is in the process of its value renaming initiated by a user).\r\n       * @returns {boolean} A flag whether the tree is being renamed.\r\n       */\r\n        function () {\r\n            return this.node._status === tree_types_1.TreeStatus.IsBeingRenamed;\r\n        };\r\n    /**\r\n     * Mark current tree as being renamed (@see {@link isBeingRenamed}).\r\n     */\r\n    /**\r\n       * Mark current tree as being renamed (@see {@link isBeingRenamed}).\r\n       */\r\n    Tree.prototype.markAsBeingRenamed = /**\r\n       * Mark current tree as being renamed (@see {@link isBeingRenamed}).\r\n       */\r\n        function () {\r\n            this.node._status = tree_types_1.TreeStatus.IsBeingRenamed;\r\n        };\r\n    /**\r\n     * Check that current tree is modified (for example it was renamed).\r\n     * @returns {boolean} A flag whether the tree is modified.\r\n     */\r\n    /**\r\n       * Check that current tree is modified (for example it was renamed).\r\n       * @returns {boolean} A flag whether the tree is modified.\r\n       */\r\n    Tree.prototype.isModified = /**\r\n       * Check that current tree is modified (for example it was renamed).\r\n       * @returns {boolean} A flag whether the tree is modified.\r\n       */\r\n        function () {\r\n            return this.node._status === tree_types_1.TreeStatus.Modified;\r\n        };\r\n    /**\r\n     * Mark current tree as modified (@see {@link isModified}).\r\n     */\r\n    /**\r\n       * Mark current tree as modified (@see {@link isModified}).\r\n       */\r\n    Tree.prototype.markAsModified = /**\r\n       * Mark current tree as modified (@see {@link isModified}).\r\n       */\r\n        function () {\r\n            this.node._status = tree_types_1.TreeStatus.Modified;\r\n        };\r\n    /**\r\n     * Makes a clone of an underlying TreeModel instance\r\n     * @returns {TreeModel} a clone of an underlying TreeModel instance\r\n     */\r\n    /**\r\n       * Makes a clone of an underlying TreeModel instance\r\n       * @returns {TreeModel} a clone of an underlying TreeModel instance\r\n       */\r\n    Tree.prototype.toTreeModel = /**\r\n       * Makes a clone of an underlying TreeModel instance\r\n       * @returns {TreeModel} a clone of an underlying TreeModel instance\r\n       */\r\n        function () {\r\n            var model = fn_utils_1.defaultsDeep(this.isLeaf() ? {} : { children: [] }, this.node);\r\n            if (this.children) {\r\n                this.children.forEach(function (child) {\r\n                    model.children.push(child.toTreeModel());\r\n                });\r\n            }\r\n            return model;\r\n        };\r\n    return Tree;\r\n}());\r\nexports.Tree = Tree;\r\n",null]}