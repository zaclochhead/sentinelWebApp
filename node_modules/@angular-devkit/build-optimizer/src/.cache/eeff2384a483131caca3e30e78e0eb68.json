{"remainingRequest":"C:\\Users\\Zac\\Desktop\\2018courses\\sentinel\\Sentinel\\WebApplication\\FrontEnd\\ngx-admin-master\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\Zac\\Desktop\\2018courses\\sentinel\\Sentinel\\WebApplication\\FrontEnd\\ngx-admin-master\\node_modules\\@asymmetrik\\ngx-leaflet\\dist\\leaflet\\layers\\leaflet-layers.directive.js","dependencies":[{"path":"C:\\Users\\Zac\\Desktop\\2018courses\\sentinel\\Sentinel\\WebApplication\\FrontEnd\\ngx-admin-master\\node_modules\\@asymmetrik\\ngx-leaflet\\dist\\leaflet\\layers\\leaflet-layers.directive.js","mtime":1514571139000},{"path":"C:\\Users\\Zac\\Desktop\\2018courses\\sentinel\\Sentinel\\WebApplication\\FrontEnd\\ngx-admin-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1527928412363},{"path":"C:\\Users\\Zac\\Desktop\\2018courses\\sentinel\\Sentinel\\WebApplication\\FrontEnd\\ngx-admin-master\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1525376550000}],"contextDependencies":[],"result":["import { Directive, Input, IterableDiffers, NgZone } from '@angular/core';\nimport { LeafletDirective } from '../core/leaflet.directive';\nimport { LeafletDirectiveWrapper } from '../core/leaflet.directive.wrapper';\n/**\n * Layers directive\n *\n * This directive is used to directly control map layers. As changes are made to the input array of\n * layers, the map is synched to the array. As layers are added or removed from the input array, they\n * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n * you must change the array instance.\n *\n * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n * immutable array implementation or create a new copy of your array when you make changes, otherwise\n * this directive won't detect the change. This is by design. It's for performance reasons. Change\n * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n * is extremely expensive from a time complexity perspective.\n *\n */\nvar LeafletLayersDirective = /*@__PURE__*/ (function () {\n    function LeafletLayersDirective(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.layersDiffer = this.differs.find([]).create();\n    }\n    Object.defineProperty(LeafletLayersDirective.prototype, \"layers\", {\n        get: function () {\n            return this.layersValue;\n        },\n        set: \n        // Set/get the layers\n        function (v) {\n            this.layersValue = v;\n            // Now that we have a differ, do an immediate layer update\n            this.updateLayers();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    LeafletLayersDirective.prototype.ngDoCheck = function () {\n        this.updateLayers();\n    };\n    LeafletLayersDirective.prototype.ngOnInit = function () {\n        // Init the map\n        this.leafletDirective.init();\n        // Update layers once the map is ready\n        this.updateLayers();\n    };\n    LeafletLayersDirective.prototype.ngOnDestroy = function () {\n        this.layers = [];\n    };\n    /**\n     * Update the state of the layers.\n     * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n     * This is important because it allows us to react to changes to the contents of the array as well\n     * as changes to the actual array instance.\n     */\n    /**\n         * Update the state of the layers.\n         * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n         * This is important because it allows us to react to changes to the contents of the array as well\n         * as changes to the actual array instance.\n         */\n    LeafletLayersDirective.prototype.updateLayers = /**\n         * Update the state of the layers.\n         * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n         * This is important because it allows us to react to changes to the contents of the array as well\n         * as changes to the actual array instance.\n         */\n        function () {\n            var map = this.leafletDirective.getMap();\n            if (null != map && null != this.layersDiffer) {\n                var changes_1 = this.layersDiffer.diff(this.layersValue);\n                if (null != changes_1) {\n                    this.zone.runOutsideAngular(function () {\n                        changes_1.forEachRemovedItem(function (c) {\n                            map.removeLayer(c.item);\n                        });\n                        changes_1.forEachAddedItem(function (c) {\n                            map.addLayer(c.item);\n                        });\n                    });\n                }\n            }\n        };\n    return LeafletLayersDirective;\n}());\nexport { LeafletLayersDirective };\n//# sourceMappingURL=leaflet-layers.directive.js.map\n",null]}